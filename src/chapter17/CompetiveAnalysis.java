package introduction.chapter17;

/**
 * 竞争性分析
 */
public class CompetiveAnalysis {
    /*
    说明： !_? 表示?在!的右下角
    1竞争性分析(by Bob Tarjan):
        应用范围: 很广 从高速缓存分析到高性能处理器分析再到硬盘分页管理分析等都是用了该基本级数
        1.1自组织表:
            包含n个元素的表L
                定义操作
                access(x)就是访问表里的元素x   说明: 该操作的代价为从表头到x的距离
                swap(x, k)置换相邻的元素       说明: 通过置换相邻的元素改变L的顺序,用以减少热频词的访问代价 该操作的代价为1
                例如:
                L [12, 3, 50, 14, 11]
                access(14) 需要的代价(cost)为4
                swap(2, 3) 需要的代价为1
            应用：
            搜索的"流行词"。在一个时期，流行词被搜索的次数会增加，而一旦过了流行期间，其位置可能就被新的流行词替代了。
            对于高速缓存等其他情况下也可能用到。

            一些其他定义:
                针对一个操作序列S (考虑俄罗斯方块)
                "在线": 每次只从S中发送一个操作请求,要求"在线"算法马上完成该操作 (只看当前落下的那个方块) 用A表示在线算法
                "离线": 可以预先看到整个S                                        (可以看到后续的整串方块) 用OPT表示离线算法
                离线算法也被称为上帝算法
                在线算法的最小化代价记作C_A(S)  离线算法的最小化代价记作C_OPT(S)  [_A表示A在C的右下角 opt相同]

            最坏情况分析(在线)：当S总是访问L的末尾元素 那么C_A(S) = Ω(|S| * n)  (假设攻击者一直访问最后的元素,这种情况下没办法处理所以我们只考虑平均情况)
            平均情况分析(在线):
                定义元素x被访问到的概率为p(x) 则E(C_A(S)) = Σp(x) * rank(x) (x∈L) [访问到x的概率乘以代价然后求和 这里的代价就是元素在L中的位置]
                当最有可能访问到的元素在最低处排列时期望最小(按照p降序排序)。

                即使不知道p也能得到如下启发: 记录每个元素被访问的次数并按访问次数递减的顺序维护这个表。
            实践:移前启发(move to front heuristic) [对于S的局部性反映较好]
                访问x后把x置换到表头去 则Cost = 2 * rank(x)  "2"要一分为二，第一部分是访问，第二部分是置换。

     (竞争性分析)
     定义A是α竞争的(α-competitive)(α读作alpha在某些软件里该字母并不容易识别),
     如果存在一个常数k满足对任意操作序列S,运用A的代价不超过α乘以OPT的代价,则如下式  [C_OPT(S)是一个可以精确计算出的已知数据  C_OPT(S)下文可能称为最优算法]
     C_A(S) <= α * C_OPT(S) + k  [如果α等于2我们说这个是双竞争的,也就是说在最坏情况下,在线算法代价是最优算法的两倍]

     定理: 自组织表的MTF(move-to-front)算法是四竞争的
     proof. (可以不看) (需要先了解摊还分析、排序中的逆序对)
     在http://open.163.com/movie/2010/12/I/2/M6UTT5U0I_M6V2U1BI2.html中22:44秒开始
     c_i hat <= 4(r^* + t_i)
     C_MIT(S) = Σc_i                                   (i = 1 to |S|)
              = Σ(c_i hat + Φ(L_(i-1)) - Φ(L_i))     (i = 1 to |S|)
              <= Σ4 * (c_i)^2 + Φ(L_0) - Φ(L_(|S|))  (i = 1 to |S|)
              <= 4 * C_OPT(S)

     在62:32开始讲B.T的论文中的内容

     参考：
     随便百度的一篇帖子 https://blog.csdn.net/u010385790/article/details/78461263
     竞争性分析视频 http://open.163.com/movie/2010/12/I/2/M6UTT5U0I_M6V2U1BI2.html
     */
}
